#include <stdio.h>#include <dirent.h>#include <stdlib.h>#include "find_pid_by_name.h"#include "Log.h"int find_pid_by_name_status(char *pidName, int *foundpid) {    LOGD("find_pid_by_name_status:%s", pidName);    DIR *dir;    struct dirent *next;    int i = 0;    //proc中包括当前的进程信息,读取该目录    dir = opendir("/proc");    if (!dir) {        LOGE("cannot open /proc");        return -1;    }    //遍历    while ((next = readdir(dir)) != NULL) {        FILE *status;        char filename[READ_BUF_SIZE];        char buffer[READ_BUF_SIZE];        char name[READ_BUF_SIZE];        if (strcmp(next->d_name, ".")==0 || strcmp(next->d_name, "..") == 0)            continue;        /* If it isn't a number, we don't want it *///		if (!isdigit(*next->d_name))//			continue;        //设置进程        sprintf(filename, "/proc/%s/status", next->d_name);//        LOGD("find /proc/%s/status", next->d_name);        if (!(status = fopen(filename, "r"))) {            continue;        }        if (fgets(buffer, READ_BUF_SIZE - 1, status) == NULL) {            fclose(status);            continue;        }        fclose(status);        //得到进程id        /* Buffer should contain a string like "Name:   lyman" */        sscanf(buffer, "%*s %s", name);//        LOGD("sscanf:%s", name);        if (strcmp(name, pidName) == 0) {            //			foundpid=realloc( foundpid, sizeof(long) * (i+2));            foundpid[i++] = strtol(next->d_name, NULL, 0);        }    }    if (foundpid)        foundpid[i] = 0;    LOGD("foundPid:%s", foundpid);    closedir(dir);    return 0;}int find_pid_by_name(char *ProcName, int *foundpid) {    DIR *dir;    struct dirent *d;    int pid, i;    char *s;    int pnlen;    i = 0;    foundpid[0] = 0;    pnlen = strlen(ProcName);    /* Open the /proc directory. */    dir = opendir("/proc");    if (!dir) {        LOGE("cannot open /proc");        return -1;    }    /* Walk through the directory. */    while ((d = readdir(dir)) != NULL) {        char exe[PATH_MAX + 1];        char path[PATH_MAX + 1];        int len;        int namelen;        /* See if this is a process */        if ((pid = atoi(d->d_name)) == 0) continue;        snprintf(exe, sizeof(exe), "/proc/%s/exe", d->d_name);        if ((len = readlink(exe, path, PATH_MAX)) < 0)            continue;        path[len] = '\0';        /* Find ProcName */        s = strrchr(path, '/');        if (s == NULL) continue;        s++;        /* we don't need small name len */        namelen = strlen(s);        if (namelen < pnlen) continue;        if (!strncmp(ProcName, s, pnlen)) {            /* to avoid subname like search proc tao but proc taolinke matched */            if (s[pnlen] == ' ' || s[pnlen] == '\0') {                foundpid[i] = pid;                i++;            }        }    }    foundpid[i] = 0;    closedir(dir);    return 0;}